// Generated by CoffeeScript 1.11.1
(function() {
  var Binding, DEFAULT_HOST, DEFAULT_PROTO, EventEmitter, MAX_BIND_RETRIES, VERBOSE, helpers, log, util, zmq,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  zmq = require('zmq');

  util = require('util');

  EventEmitter = require('events').EventEmitter;

  helpers = require('./helpers');

  log = helpers.log;

  VERBOSE = parseInt(process.env.SOMATA_VERBOSE || 0);

  DEFAULT_PROTO = process.env.SOMATA_PROTO || 'tcp';

  DEFAULT_HOST = process.env.SOMATA_HOST || '127.0.0.1';

  MAX_BIND_RETRIES = 5;

  module.exports = Binding = (function(superClass) {
    extend(Binding, superClass);

    Binding.prototype.pending_responses = {};

    Binding.prototype.subscriptions = {};

    Binding.prototype.known_pings = {};

    function Binding(options) {
      if (options == null) {
        options = {};
      }
      Object.assign(this, options);
      this.id || (this.id = helpers.randomString());
      this.proto || (this.proto = DEFAULT_PROTO);
      this.host || (this.host = DEFAULT_HOST);
      if (this.proto !== 'ipc') {
        this.port || (this.port = helpers.randomPort());
      }
      this.should_retry = options.port == null;
      this.tryBind();
    }

    Binding.prototype.emitNext = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return process.nextTick((function(_this) {
        return function() {
          return _this.emit.apply(_this, args);
        };
      })(this));
    };

    Binding.prototype.tryBind = function(n_retried) {
      var err;
      if (n_retried == null) {
        n_retried = 0;
      }
      try {
        this.address = helpers.makeAddress(this.proto, this.host, this.port);
        if (VERBOSE) {
          log.d("[Binding.tryBind] Attempting to bind on " + this.address + "...");
        }
        this.socket = zmq.socket('router');
        this.socket.bindSync(this.address);
        return this.didBind();
      } catch (error) {
        err = error;
        log.e("[Binding.tryBind] Failed to bind on " + this.address, err);
        if (!this.should_retry) {
          return process.exit();
        } else if (n_retried < MAX_BIND_RETRIES) {
          log.w("[Binding.tryBind] Retrying...");
          this.port = helpers.randomPort();
          return setTimeout((function(_this) {
            return function() {
              return _this.tryBind(n_retried + 1);
            };
          })(this), 1000);
        } else {
          log.e("[Binding.tryBind] Retried too many times.");
          return process.exit();
        }
      }
    };

    Binding.prototype.didBind = function() {
      if (VERBOSE) {
        log.i("[Binding.didBind] Socket " + this.id + " bound to " + this.address);
      }
      this.emitNext('bind');
      this.socket.on('message', (function(_this) {
        return function(client_id, message_json) {
          return _this.handleMessage(client_id.toString(), JSON.parse(message_json));
        };
      })(this));
      this.on('ping', this.handlePing.bind(this));
      this.on('method', this.handleMethod.bind(this));
      this.on('subscribe', this.handleSubscribe.bind(this));
      return this.on('unsubscribe', this.handleUnsubscribe.bind(this));
    };

    Binding.prototype.handleMessage = function(client_id, message) {
      var cb, ref;
      if (VERBOSE > 1) {
        log.d("[Binding.handleMessage] <" + client_id + "> " + (helpers.summarizeMessage(message)));
      }
      if (cb = (ref = this.pending_responses[client_id]) != null ? ref[message.id] : void 0) {
        return cb(message);
      } else {
        return this.emit(message.kind, client_id, message);
      }
    };

    Binding.prototype.handlePing = function(client_id, message) {
      var pong;
      if (message.ping === 'hello' || (this.known_pings[message.id] == null)) {
        this.known_pings[message.id] = true;
        this.emitNext('connected', client_id);
        pong = 'welcome';
      } else {
        pong = 'pong';
      }
      this.setPingTimeout(client_id);
      return this.send(client_id, {
        id: message.id,
        pong: pong
      });
    };

    Binding.prototype.ping_timeouts = {};

    Binding.prototype.setPingTimeout = function(client_id) {
      var pingDidTimeout;
      clearTimeout(this.ping_timeouts[client_id]);
      pingDidTimeout = this.pingDidTimeout.bind(this, client_id);
      return this.ping_timeouts[client_id] = setTimeout(pingDidTimeout, 2500);
    };

    Binding.prototype.clearSubscriptions = function(client_id) {
      var ref, results, subscription, subscription_id, subscription_type, subscriptions;
      ref = this.subscriptions;
      results = [];
      for (subscription_type in ref) {
        subscriptions = ref[subscription_type];
        results.push((function() {
          var ref1, results1;
          results1 = [];
          for (subscription_id in subscriptions) {
            subscription = subscriptions[subscription_id];
            if (subscription.client_id === client_id) {
              delete this.subscriptions[subscription_type][subscription_id];
              results1.push((ref1 = this.pending_responses[client_id]) != null ? delete ref1[subscription_id] : void 0);
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Binding.prototype.pingDidTimeout = function(client_id) {
      this.clearSubscriptions(client_id);
      delete this.known_pings[client_id];
      if (VERBOSE) {
        log.w('[Binding.pingDidTimeout]', client_id);
      }
      return this.emit('timeout', client_id);
    };

    Binding.prototype.handleMethod = function(client_id, message) {
      var method, ref, response;
      if (VERBOSE) {
        log.d("[Binding.handleMethod]", message);
      }
      if (message.service != null) {

      } else if (method = (ref = this.methods) != null ? ref[message.method] : void 0) {
        return response = method.apply(null, slice.call(message.args).concat([(function(_this) {
          return function(err, response) {
            return _this.send(client_id, {
              id: message.id,
              kind: 'response',
              response: response
            });
          };
        })(this)]));
      } else {
        return this.send(client_id, {
          id: message.id,
          kind: 'error',
          error: "Unknown method '" + message.method + "'"
        });
      }
    };

    Binding.prototype.handleSubscribe = function(client_id, subscription) {
      var base, name;
      if (VERBOSE) {
        log.d('[Binding.handleSubscribe]', client_id, subscription);
      }
      subscription.client_id = client_id;
      (base = this.subscriptions)[name = subscription.type] || (base[name] = {});
      return this.subscriptions[subscription.type][subscription.id] = subscription;
    };

    Binding.prototype.handleUnsubscribe = function(client_id, unsubscription) {
      var ref;
      if (VERBOSE) {
        log.d('[Binding.handleUnsubscribe]', client_id, unsubscription);
      }
      return (ref = this.subscriptions[unsubscription.type]) != null ? delete ref[unsubscription.id] : void 0;
    };

    Binding.prototype.send = function(client_id, message, cb) {
      var base;
      if (cb != null) {
        message.id || (message.id = helpers.randomString());
        (base = this.pending_responses)[client_id] || (base[client_id] = {});
        this.pending_responses[client_id][message.id] = cb;
      }
      return this.socket.send([client_id, JSON.stringify(message)]);
    };

    Binding.prototype.method = function() {
      var args, cb, client_id, i, method;
      client_id = arguments[0], method = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
      return this.send(client_id, {
        kind: 'method',
        method: method,
        args: args
      }, function(message) {
        return cb(message.error, message.response, message);
      });
    };

    Binding.prototype.subscribe = function() {
      var args, cb, client_id, i, type;
      client_id = arguments[0], type = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
      return this.send(client_id, {
        kind: 'subscribe',
        type: type,
        args: args
      }, function(message) {
        return cb(message.error || message.event, message);
      });
    };

    Binding.prototype.unsubscribe = function(client_id, type, id, cb) {
      return this.send(client_id, {
        kind: 'unsubscribe',
        type: type,
        id: id
      });
    };

    Binding.prototype.publish = function(type, event) {
      var client_id, i, id, len, ref, results, subscription, subscriptions;
      subscriptions = this.subscriptions[type];
      ref = helpers.values(subscriptions);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        subscription = ref[i];
        id = subscription.id, client_id = subscription.client_id;
        results.push(this.send(client_id, {
          id: id,
          type: type,
          event: event
        }));
      }
      return results;
    };

    return Binding;

  })(EventEmitter);

}).call(this);
