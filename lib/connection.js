// Generated by CoffeeScript 1.11.1
(function() {
  var Connection, DEFAULT_CONNECT, DEFAULT_PROTO, EventEmitter, PING_INTERVAL, VERBOSE, _, helpers, log, util, zmq,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  zmq = require('zmq');

  util = require('util');

  _ = require('underscore');

  EventEmitter = require('events').EventEmitter;

  helpers = require('./helpers');

  log = helpers.log;

  VERBOSE = parseInt(process.env.SOMATA_VERBOSE || 0);

  DEFAULT_PROTO = process.env.SOMATA_PROTO || 'tcp';

  DEFAULT_CONNECT = process.env.SOMATA_CONNECT || process.env.SOMATA_REGISTRY_HOST || '127.0.0.1';

  PING_INTERVAL = parseInt(process.env.SOMATA_PING_INTERVAL) || 2000;

  module.exports = Connection = (function(superClass) {
    extend(Connection, superClass);

    Connection.prototype.pending_responses = {};

    Connection.prototype.subscriptions = {};

    function Connection(options) {
      if (options == null) {
        options = {};
      }
      Object.assign(this, options);
      this.id || (this.id = helpers.randomString());
      this.proto || (this.proto = DEFAULT_PROTO);
      this.host || (this.host = DEFAULT_CONNECT);
      if (this.host === '0.0.0.0') {
        this.host = DEFAULT_CONNECT;
      }
      this.address = helpers.makeAddress(this.proto, this.host, this.port);
      this.connect();
    }

    Connection.prototype.connect = function() {
      this.socket = zmq.socket('dealer');
      this.socket.identity = this.id;
      this.socket.connect(this.address);
      this.socket.on('message', (function(_this) {
        return function(message_json) {
          return _this.handleMessage(JSON.parse(message_json));
        };
      })(this));
      if (VERBOSE) {
        log.i("[Connection.connect] " + (helpers.summarizeConnection(this)) + " connected to " + this.address + "...");
      }
      return this.connected();
    };

    Connection.prototype.connected = function() {
      this.on('method', this.handleMethod.bind(this));
      this.on('subscribe', this.handleSubscribe.bind(this));
      return this.sendPing();
    };

    Connection.prototype.handleMessage = function(message) {
      var on_response;
      if (VERBOSE > 1) {
        log.d("[Connection.handleMessage] " + (helpers.summarizeConnection(this)) + " " + (helpers.summarizeMessage(message)));
      }
      if (on_response = this.pending_responses[message.id]) {
        if (on_response.timeout != null) {
          clearTimeout(on_response.timeout);
        }
        if (on_response.once) {
          delete this.pending_responses[message.id];
        }
        return on_response(message);
      } else if (message.kind != null) {
        return this.emit(message.kind, message);
      } else {
        if (VERBOSE) {
          log.w('[handleMessage] No pending response for ' + message.id);
        }
        return log.w('[handleMessage] No pending response for', message);
      }
    };

    Connection.prototype.handleMethod = function(message) {
      var method, ref, response;
      if (VERBOSE) {
        log.d("[Connection.on method]", message);
      }
      if (method = (ref = this.methods) != null ? ref[message.method] : void 0) {
        return response = method.apply(null, slice.call(message.args).concat([(function(_this) {
          return function(err, response) {
            return _this.send({
              id: message.id,
              kind: 'response',
              response: response
            });
          };
        })(this)]));
      } else {
        return this.send({
          id: message.id,
          kind: 'error',
          error: "Unknown method"
        });
      }
    };

    Connection.prototype.handleSubscribe = function(subscription) {
      var base, name;
      if (VERBOSE) {
        log.d('[Connection.on subscribe]', subscription);
      }
      log.d('[Connection.on subscribe]', subscription);
      (base = this.subscriptions)[name = subscription.type] || (base[name] = {});
      return this.subscriptions[subscription.type][subscription.id] = subscription;
    };

    Connection.prototype.handleUnsubscribe = function(unsubscription) {};

    Connection.prototype.send = function(message, cb) {
      var ref;
      message.id || (message.id = helpers.randomString(16));
      message.service || (message.service = (ref = this.service) != null ? ref.id : void 0);
      if (cb != null) {
        this.pending_responses[message.id] = cb;
      }
      this.socket.send(JSON.stringify(message));
      return message;
    };

    Connection.prototype.method = function() {
      var args, cb, i, method;
      method = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), cb = arguments[i++];
      if (cb != null) {
        cb.once = true;
      }
      return this.send({
        kind: 'method',
        method: method,
        args: args
      }, function(message) {
        return cb(message.error, message.response, message);
      });
    };

    Connection.prototype.subscribe = function() {
      var args, cb, i, type;
      type = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), cb = arguments[i++];
      return this.send({
        kind: 'subscribe',
        type: type,
        args: args
      }, function(message) {
        return cb(message.error, message.event, message);
      });
    };

    Connection.prototype.unsubscribe = function(id) {
      return this.send({
        kind: 'unsubscribe',
        id: id
      });
    };

    Connection.prototype.publish = function(type, event) {
      var i, id, len, ref, results, subscription, subscriptions;
      subscriptions = this.subscriptions[type];
      ref = helpers.values(subscriptions);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        subscription = ref[i];
        id = subscription.id;
        results.push(this.send({
          id: id,
          type: type,
          event: event
        }));
      }
      return results;
    };

    Connection.prototype.last_ping = null;

    Connection.prototype.last_pong = null;

    Connection.prototype.sendPing = function() {
      var message, ping, ref, ref1;
      this.pongTimeoutTimeout = setTimeout(this.pongDidTimeout.bind(this), PING_INTERVAL);
      ping = this.last_pong != null ? 'ping' : 'hello';
      message = {
        id: (ref = this.last_ping) != null ? ref.id : void 0,
        kind: 'ping',
        ping: ping,
        service: (ref1 = this.service) != null ? ref1.id : void 0
      };
      return this.last_ping = this.send(message, this.handlePong.bind(this));
    };

    Connection.prototype.handlePong = function(message) {
      var is_new;
      if (this.closed) {
        log.e('[handlePong] Closed connection');
        return;
      }
      if (message.pong === 'welcome') {
        if (VERBOSE || true) {
          log.i("[Connection.handlePong] " + (helpers.summarizeConnection(this)) + " New ping response");
        }
        is_new = this.last_pong == null;
        this.clearSubscriptions();
        this.emit('connect', is_new);
        this.last_pong = new Date();
      } else {
        if (VERBOSE > 2) {
          log.d("[Connection.handlePong] " + (helpers.summarizeConnection(this)) + " Continuing ping");
        }
        this.last_pong = new Date();
      }
      clearTimeout(this.pongTimeoutTimeout);
      return this.nextPingTimeout = setTimeout(this.sendPing.bind(this), PING_INTERVAL);
    };

    Connection.prototype.pongDidTimeout = function() {
      log.e("[Connection.pongDidTimeout] " + (helpers.summarizeConnection(this)));
      delete this.last_ping;
      delete this.last_pong;
      this.clearSubscriptions();
      return this.emit('timeout');
    };

    Connection.prototype.clearSubscriptions = function() {
      var ref, results, subscription, subscription_id, subscription_type, subscriptions;
      ref = this.subscriptions;
      results = [];
      for (subscription_type in ref) {
        subscriptions = ref[subscription_type];
        results.push((function() {
          var results1;
          results1 = [];
          for (subscription_id in subscriptions) {
            subscription = subscriptions[subscription_id];
            delete this.subscriptions[subscription_type][subscription_id];
            results1.push(delete this.pending_responses[subscription_id]);
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Connection.prototype.close = function() {
      log.e("[Connection.close] " + (helpers.summarizeConnection(this)));
      delete this.last_ping;
      delete this.last_pong;
      clearTimeout(this.nextPingTimeout);
      clearTimeout(this.pongTimeoutTimeout);
      this.closed = true;
      return this.socket.close();
    };

    return Connection;

  })(EventEmitter);

}).call(this);
