// Generated by CoffeeScript 1.8.0
var ansi, crypto, date_format, descend, log, logDate, moment, util, _;

util = require('util');

crypto = require('crypto');

_ = require('underscore');

moment = require('moment');

ansi = require('ansi')(process.stdout, {
  enabled: true
});

exports.values = function(object) {
  var k, v, vs;
  vs = [];
  for (k in object) {
    v = object[k];
    vs.push(v);
  }
  return vs;
};

date_format = 'YYYY-MM-DD hh:mm:ss';

logDate = function() {
  ansi.grey();
  ansi.write('[' + moment().format(date_format) + '] ');
  return ansi.reset();
};

exports.log = log = function(s, d, options) {
  if (options == null) {
    options = {};
  }
  if ((options.date == null) || options.date) {
    logDate();
  }
  if (options.hex != null) {
    ansi.hex(options.hex);
  }
  if (options.color != null) {
    ansi.fg[options.color]();
  }
  ansi.write(s);
  ansi.reset();
  if (d != null) {
    ansi.write(' ' + util.inspect(d, {
      colors: true
    }));
  }
  return ansi.write('\n');
};

log.w = function(s, d) {
  return log(s, d, {
    color: 'yellow'
  });
};

log.i = function(s, d) {
  return log(s, d, {
    color: 'cyan'
  });
};

log.e = function(s, d) {
  return log(s, d, {
    color: 'red'
  });
};

log.d = function(s, d) {
  return log(s, d, {
    color: 'grey'
  });
};

log.s = function(s, d) {
  return log(s, d, {
    color: 'green'
  });
};

exports.capitalize = function(type) {
  return type[0].toUpperCase() + type.slice(1);
};

exports.randomChoice = function(list) {
  return list[Math.floor(Math.random() * list.length)];
};

exports.randomString = function(len) {
  var s;
  if (len == null) {
    len = 8;
  }
  s = '';
  while (s.length < len) {
    s += Math.random().toString(36).slice(2, len - s.length + 2);
  }
  return s;
};

exports.summarizeMessage = function(message) {
  return util.inspect(message).slice(0, 100).replace(/\s+/g, ' ');
};

exports.summarizeClient = function(client) {
  return "<" + client.id + "> " + client.address;
};

exports.summarizeConnection = function(connection) {
  return "<" + connection.id + "> " + connection.address;
};

exports.summarizeService = function(service) {
  return service.name + '@' + service.binding.host + ':' + service.binding.port;
};

exports.makeAddress = function(proto, host, port) {
  var address;
  port = parseInt(port);
  address = proto + '://' + host;
  if (proto !== 'ipc') {
    address += ':' + port;
  }
  return address;
};

exports.randomPort = function() {
  return 10000 + Math.floor(Math.random() * 50000);
};

descend = function(o, c) {
  if (c.length === 1) {
    return o[c[0]].bind(o);
  } else {
    return descend(o[c.shift()], c);
  }
};

exports.descend = descend;

exports.parseAddress = function(s, default_host, default_port) {
  var host, port, _ref;
  if (s == null) {
    if (default_host != null) {
      return {
        host: default_host,
        port: default_port
      };
    } else {
      return null;
    }
  } else {
    _ref = s.split(':'), host = _ref[0], port = _ref[1];
    host || (host = default_host);
    port || (port = default_port);
    return {
      host: host,
      port: port
    };
  }
};
